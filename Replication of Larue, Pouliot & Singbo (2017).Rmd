---
title: "Replication of results in Larue, Pouliot and Singbo (2017)"
author: 
  - Sebastien Pouliot
date: Fall 2018
output:
  pdf_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    number_sections : no
  html_document: default
  word_document: default
header-includes:
    - \usepackage{booktabs}
    - \usepackage[table, dvipsnames]{xcolor}
    - \usepackage{longtable}
    - \clubpenalty=10000 #The next 3 lines are to avoid widows and orphans
    - \widowpenalty=10000
    - \displaywidowpenalty=10000
fontsize: 12pt
geometry: margin=1in
documentclass: article
bibliography: References.bib
biblio-style: apalike
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, include = TRUE, message = FALSE, warning = FALSE, tidy = TRUE, tidy.opts=list(blank=FALSE, width.cutoff=35), collapse = TRUE, fig.pos = 'phtb')

#Load some packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse)
pacman::p_load(readxl)
pacman::p_load(xlsx)
pacman::p_load(magrittr)
pacman::p_load(haven)
pacman::p_load(viridis)
pacman::p_load(Cairo)
options(kableExtra.latex.load_packages = FALSE)
pacman::p_load(kableExtra)
pacman::p_load(npsf)

#Basic setup for figures
source("Figures/Graph parameters.r")

```

In this document I reproduce the results in @Larue2017, with their paper titled [Production Rigidity, Input Lumpiness, Efficiency, and the Technological Hurdle of Quebec Dairy Farms](https://onlinelibrary.wiley.com/doi/full/10.1111/cjag.12156). The Stata file `Rigidity_lumpiness_efficiency_hurdle.do` contains the code used in @Larue2017 to estimate stochastic frontier models.

All the material necessary to produce this document is available on my Github page at <https://github.com/SebPouliot>. This pdf document is generated by compiling the file `Replication of Larue, Pouliot & Singbo (2017).Rmd`.

I begin by generating the figures in the article that were produced using R. I then turn into preparing the data and then finally I estimate the results in the model.^[I had to use horizontable lines to separate sections and subsections of the document. Otherwise, the text extended beying the margin at the bottom for one page and I do not know what caused this.]


## Figures

Figures 2, 3 and 4 were generated using R. Figure 2 and 3 use data from a survey of dairy farms in Québec. Figure 4 is based on functional forms and numerical solutions.


### Figure 2

Figure 2 in the article (figure \ref{fig2} in this document) uses the data available in the subfolder `Data` under the name `Quota trade.xlsx`. I save all figures into the subfolder `Figures` using the figure number. 


```{r figure2, dev='cairo_pdf', fig.cap="Prices (a) and volume traded (b) on Quebec’s production quota exchange (Figure 2) \\label{fig2}"}

#Load data
dta <- read_excel("Data/Quota trade.xlsx") %>%
  mutate(date = as.Date(time)) %>%
  rename(Price = price, `Price ceiling` = priceceiling)

################
### Figure 2 ###
################

dta_graph <- dta %>%
  dplyr::select(date, Price, `Price ceiling`) %>%
  gather(var, price, c(Price, `Price ceiling`))

plot1 <- ggplot(dta_graph, aes(x = date, y = price, color = var)) +
  geom_line(size = 1) +
  scale_x_date(date_labels = "%Y", date_breaks = "year") +
  ylab("Price ('000 $CA)") +
  scale_color_viridis(discrete = TRUE) +
  theme_bw() +
  mytheme +
  theme(legend.direction = "horizontal",
        legend.position= c(0.40, 0.95),
        axis.title.x=element_blank(),
        axis.line.x = element_line(color='black'),
        axis.line.y = element_line(color='black')) +
  labs(title = "a) Quota price")

plot2 <- ggplot(dta, aes(x = date, y = volumetraded)) +
  geom_line(size = 1) +
  scale_x_date(date_labels = "%Y", date_breaks = "year") +
  ylab("Volume traded (kg/day)") +
  theme_bw() +
  mytheme +
  theme(legend.direction = "horizontal",
        legend.position= c(0.40, 0.95),
        axis.title.x=element_blank(),
        axis.line.x = element_line(color='black'),
        axis.line.y = element_line(color='black')) +
  labs(title = "b) Volume of quota traded")


fig2 <- grid.arrange(plot1, plot2, ncol=1, nrow =2)

ggsave(fig2, filename = "Figures/Figure 2.png",  width = 6, height = 6, units = "in", dpi = 600)
```

---

### Figure 3

The data to produce figure 3 (figure \ref{fig3} in this document) are the same as in those to create figure 2.

```{r figure 3, dev='cairo_pdf', fig.cap="Number of buyers and sellers involved in production quota trades in Quebec (Figure 3) \\label{fig3}"}

################
### Figure 3 ###
################

dta_graph <- dta %>%
  dplyr::select(date, sellers, buyers) %>%
  rename(`Number of sellers` = sellers, `Number of buyers` = buyers) %>%
  gather(var, number, c(`Number of sellers`, `Number of buyers`))

fig3 <- ggplot(dta_graph, aes(x = date, y = number, color = var)) +
  geom_line(size = 1) +
  scale_x_date(labels = date_format("%Y"), breaks = date_breaks("year")) +
  scale_color_viridis(discrete = TRUE) +
  theme_bw() +
  mytheme +
  theme(legend.direction = "horizontal",
        legend.position= c(0.40, 0.95),
        axis.title.x=element_blank(),
        axis.line.x = element_line(color='black'),
        axis.title.y=element_blank(), axis.line.y = element_line(color='black'))

ggsave(fig3, filename = "Figures/Figure 3.png",  width = 6, height = 4, units = "in", dpi = 600)

print(fig3)
```

---

### Figure 4

Figure 4 (figure \ref{fig4} in this document) uses functional forms and numerical values. The code below shows how to produce that figure.

```{r figure 4, dev='cairo_pdf', fig.cap = "Input lumpiness and allocative efficiency (Figure 4) \\label{fig4}"}

#Produce data for graph
dta <- array(NA, c(2500, 1)) %>% tbl_df %>% rename(L = V1)

dta <- dta %>% mutate(L = seq(0, 250, length.out = nrow(dta))) %>%
  mutate(K_100 = 100^2/L, C_100 = 200-1*L) %>%
  mutate(K_89 = (10*80^0.5)^2/L, C_89 = (200)-1.25*L) %>%
  mutate(K_71 = (10*50^0.5)^2/L, C_71 = (200)-2*L) %>%
  mutate(K_179 = (200^.5*160^0.5)^2/L, C_179 = (200*1 + 160*1.25)-1.25*L) %>%
  mutate(K_141 = (200^.5*100^0.5)^2/L, C_141 = (200*1 + 100*2)-2*L)

for (k in 2:ncol(dta)){
 dta[dta[,k] > 250,k] <- NA
}

#Plot the lines
color_list <- viridis(5)

p <- ggplot() +
  geom_line(data = dta, aes(x = L, y = K_100), size = 1, color = color_list[1]) +
  geom_line(data = dta, aes(x = L, y = C_100), size = 1, color = color_list[1])+
  geom_line(data = dta, aes(x = L, y = K_89), size = 1, color = color_list[2]) +
  geom_line(data = dta, aes(x = L, y = C_89), size = 1, color = color_list[2]) +
  geom_line(data = dta, aes(x = L, y = K_71), size = 1, color = color_list[3]) +
  geom_line(data = dta, aes(x = L, y = C_71), size = 1, color = color_list[3]) +
  geom_line(data = dta, aes(x = L, y = K_179), size = 1, color = color_list[4]) +
  geom_line(data = dta, aes(x = L, y = C_179), size = 1, color = color_list[4]) +
  geom_line(data = dta, aes(x = L, y = K_141), size = 1, color = color_list[5]) +
  geom_line(data = dta, aes(x = L, y = C_141), size = 1, color = color_list[5]) +
  geom_hline(yintercept = 100, linetype = 2) +
  geom_hline(yintercept = 200, linetype = 2) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,250)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0,250))

#Add labels
p <- p + annotate("text", x = 101, y = 106, label = "a", size=4, family = "Times New Roman") +
  annotate("text", x = 81, y = 106, label = "b", size=4, family = "Times New Roman") +
  annotate("text", x = 161, y = 206, label = "c", size=4, family = "Times New Roman") +
  annotate("text", x = 51, y = 106, label = "d", size=4, family = "Times New Roman") +
  annotate("text", x = 101, y = 206, label = "e", size=4, family = "Times New Roman") +
  annotate("text", x = 38, y = 245, label = "100", size=2.5, family = "Times New Roman") +
  annotate("text", x = 28, y = 245, label = "89.44", size=2.5, family = "Times New Roman") +
  annotate("text", x = 138, y = 245, label = "178.89", size=2.5, family = "Times New Roman") +
  annotate("text", x = 15, y = 245, label = "70.71", size=2.5, family = "Times New Roman") +
  annotate("text", x = 88, y = 245, label = "141.42", size=2.5, family = "Times New Roman")

#Axis labels and theme

p <- p + ylab("Capital (K)") +
  ylab("Capital (K)") +
  xlab("Labor (L)")+
  theme_bw() +
  mytheme

ggsave(p, filename = "Figures/Figure 4.png",  width = 6, height = 6, units = "in", dpi = 600)

p

```

---

## Data

The paper explains that the data are a farm account series from the *Groupe Conseils Agricoles du Quebec*, a management group in the province of Quebec, and thus only members of this group are part of the sample. The table below defines the variables in the data. The variables `dbef2009` and `daft2009` are only used in robustness checks performed in the Stata `.do` file available on the Github repository.

Table: Definitions of variables

| Name         | Definition                                 |
|:-------------|:-------------------------------------------|
| labo         | Labor quantity (fte)                       |
| feed         | Value of feed input (\$)                   |
| machi        | Value of machinery input (\$)              |
| ocapi        | Value of other capital (\$)                |
| vout1        | Value of dairy output (\$)                 |
| otout1       | Value of other output (\$)                 |
| land         | Land area (HA)                             |
| Age          | Age of operator                            |
| north        | Dummy variable for north region            |
| south        | Dummy variable for south region            |
| offwork      | Dummy for operator working off farm        | 
| dbef2009     | Dummy for a farm observed only before 2009 |
| daft2009     | Dummy for a farm observed only affter 2009 |

In the chunk that follows, I create from the raw data the necessary columns to estimate regression models. The table below provides the definion of the variables in the database.

I save the data as `Clean data.xlsx` file and in Stata for as `Clean data.dta` in the `Data` folder.

```{r data}

dta <- read_excel("Data/Raw data.xlsx")

#Create data for estimation
dta <- dta %>%
  mutate(mland = log(land) - mean(log(land)),
         mland1 = - mland,
         mlvout1 = log(vout1) - mean(log(vout1)),
         mlotout1 = log(otout1) - mean(log(otout1)),
         mlfeed1 = log(feed) - mean(log(feed)) - mland,
         mlabo1 = log(labo) - mean(log(labo)) - mland,
         mlmach1 = log(machi) - mean(log(machi)) - mland,
         mlocapi1 = log(ocapi) - mean(log(ocapi)) - mland,
         mlvout2 = mlvout1^2,
         mlotout2 = mlotout1^2,
         mlfeed2 =  mlfeed1^2,
         mlabo2 = mlabo1^2,
         mlmach2 = mlmach1^2,
         mlocapi2 = mlocapi1^2,
         lout12 = mlvout1 * mlotout1,
         out1_feed = mlvout1 * mlfeed1,
         out1_lab = mlvout1 * mlabo1,
         out1_mach = mlvout1 * mlmach1,
         out1_ocap = mlvout1 * mlocapi1,
         out2_feed = mlotout1 * mlfeed1,
         out2_lab = mlotout1 * mlabo1,
         out2_mach = mlotout1 * mlmach1,
         out2_ocap = mlotout1 * mlocapi1,
         feed_lab = mlfeed1 * mlabo1,
         feed_mach = mlfeed1 * mlmach1,
         feed_ocap = mlfeed1 * mlocapi1,
         lab_mach = mlabo1 * mlmach1,
         lab_ocap = mlabo1 * mlocapi1,
         mach_ocap = mlmach1 * mlocapi1)

### Create the dummies and time trend

dta <- dta %>%
  mutate(time = year - 2000,
         d2005 = as.numeric(year == 2005),
         d2006 = as.numeric(year == 2006),
         d2007 = as.numeric(year == 2007),
         d2008 = as.numeric(year == 2008),
         d2009 = as.numeric(year == 2009),
         d2010 = as.numeric(year == 2010),
         d2009a = as.numeric(year >= 2009),
         t2009a = time*d2009a)


write.xlsx(data.frame(dta), "Data/Clean data.xlsx", sheetName = "Sheet1", col.names = TRUE, row.names = FALSE, append = FALSE)

write_dta(data.frame(dta), "Data/Clean data.dta", version = 14)


```

Table \ref{tab.summary} summarizes the data. 

```{r summary} 

table2 <- dta %>%
  dplyr::select(id, year, labo, feed, machi, ocapi, vout1, otout1, land, age, north, south, offwork) %>%
  rename(`01) Labor` = labo, 
         `02) Feed` = feed, 
         `03) Machinery` = machi, 
         `04) Other capital` = ocapi, 
         `05) Dairy output` = vout1, 
         `06) Other output` = otout1, 
         `07) Land` = land, 
         `08) Age` = age, 
         `09) North` = north, 
         `10) South` = south, 
         `11) Off-farm work` = offwork) %>%
  gather(Variable, value, -c(year, id)) %>%
  group_by(Variable) %>%
  summarize(Mean = round(mean(value),2), 
            P50 = round(median(value),2), 
            SD = round(sd(value),2)) %>%
  mutate(Units = c("Full time equivalent", "$", "$", "$", "$", "$", "HA", "Years", "Binary", "Binary", "Binary")) %>%
  dplyr::select(Variable, Units, Mean, P50, SD) %>%
  mutate(Mean = ifelse(Mean >= 100, round(Mean, 0), Mean),
         P50 = ifelse(P50 >= 100, round(P50, 0), P50),
         SD = ifelse(SD >= 100, round(SD, 0), SD))

kable(table2, format = "latex", 
      caption = paste0("Summary of selected ", "variables ", "(number of observations, N = 549)", "\\label{tab.summary}"), booktabs = T, linesep = "", align = c("l", "c", "c", "c", "c"), format.args = list(decimal.mark = '.', big.mark = ",")) %>%
  kable_styling(latex_options = c("striped", "hold_position"))

```

---

## Results

In the chunks below I reproduce the results in the paper. Several of the coefficients are reported in an appendix table in the paper. Below, the coefficient estimates for the production function and efficiency are all reported together in separate tables. I calculate average efficiency per period in a table on its own. Note that there small differences with the results in model reported in the paper because of a small difference in the way to define a dummy variable.

---

### Model 1

Table \ref{tab.mod1} shows the results from model 1. 

```{r model1}

###############
### Model 1 ###
###############

mod1 <- sf(mland1 ~ mlvout1 + mlotout1 + mlfeed1 + mlabo1 + mlmach1 + mlocapi1 + mlvout2 + mlotout2 + mlfeed2 + mlabo2 + mlmach2 + mlocapi2 + lout12 + out1_feed + out1_lab + out1_mach + out1_ocap + out2_feed + out2_lab + out2_mach + out2_ocap + feed_lab + feed_mach + feed_ocap + lab_mach + lab_ocap + mach_ocap, data = dta, distribution = c("t"), eff.time.invariant = TRUE, mean.u.0i = ~ age + offwork + north + south + time + d2009a + t2009a, print.level = 0)

keep1 <- rownames(mod1$table)[!rownames(mod1$table) %in% c("logVv_intercept", "logVu_intercept", "lambda   ", "gamma   ", "sigma_v  ", "sigma_u  ")]

kable(mod1$table[keep1,], format = "latex", longtable = T, booktabs = T,
  linesep = "", caption = "Results from model 1 \\label{tab.mod1}") %>%
  kable_styling("repeat_header", latex_options = "striped")

```

---

### Model 2

Table \ref{tab.mod2} shows the results from model 2. Convergence is difficult in model 2 and setting the seed before estimating the model allows for the estimation to consistently converge to the same results as when using Stata. 

```{r model2}

###############
### Model 2 ###
###############

set.seed(533573)

mod2 <- sf(mland1 ~ mlvout1 + mlotout1 + mlfeed1 + mlabo1 + mlmach1 + mlocapi1 + mlvout2 + mlotout2 + mlfeed2 + mlabo2 + mlmach2 + mlocapi2 + lout12 + out1_feed + out1_lab + out1_mach + out1_ocap + out2_feed + out2_lab + out2_mach + out2_ocap + feed_lab + feed_mach + feed_ocap + lab_mach + lab_ocap + mach_ocap + time, data = dta, distribution = c("t"), eff.time.invariant = TRUE, mean.u.0i = ~ age + offwork + north + south + d2009a + t2009a, print.level = 0)

keep2 <- rownames(mod2$table)[!rownames(mod2$table) %in% c("logVv_intercept", "logVu_intercept", "lambda   ", "gamma   ", "sigma_v  ", "sigma_u  ")]

kable(mod2$table[keep2,], format = "latex", caption = "Results from model 2 \\label{tab.mod2}", booktabs = T, linesep = "") %>%
  kable_styling("repeat_header", latex_options = "striped")

```

---

### Model 3

Table \ref{tab.mod3} shows the results from model 3.

```{r model3}

###############
### Model 3 ###
###############

mod3 <- sf(mland1 ~ mlvout1 + mlotout1 + mlfeed1 + mlabo1 + mlmach1 + mlocapi1 + mlvout2 + mlotout2 + mlfeed2 + mlabo2 + mlmach2 + mlocapi2 + lout12 + out1_feed + out1_lab + out1_mach + out1_ocap + out2_feed + out2_lab + out2_mach + out2_ocap + feed_lab + feed_mach + feed_ocap + lab_mach + lab_ocap + mach_ocap, data = dta, distribution = c("t"), eff.time.invariant = TRUE, mean.u.0i = ~ age + offwork + north + south + d2005 + d2006 + d2007 + d2008 + d2009 + d2010, print.level = 0)

keep3 <- rownames(mod3$table)[!rownames(mod3$table) %in% c("logVv_intercept", "logVu_intercept", "lambda   ", "gamma   ", "sigma_v  ", "sigma_u  ")]

kable(mod3$table[keep3, ], format = "latex", caption = "Results from model 3 \\label{tab.mod3}", booktabs = T, linesep = "") %>%
  kable_styling("repeat_header", latex_options = "striped")

```

---

### Average technical efficiency per period

Table \ref{tab.tech} report average efficiency per period.


```{r results}

eff1 <- cbind(mod1$efficiencies, year = dta$year) %>%
  mutate(Model = "Model 1")
eff2 <- cbind(mod2$efficiencies, year = dta$year) %>%
  mutate(Model = "Model 2")
eff3 <- cbind(mod3$efficiencies, year = dta$year) %>%
  mutate(Model = "Model 3")

eff <- rbind(eff1, eff2) %>% rbind(eff3)
  
eff <- eff %>%
  mutate(gyear = case_when(year %in% 2001:2008 ~ "Ave.eff. 2001-08",
                           year == 2009 ~ "Ave.eff. 2009",
                           year == 2010 ~ "Ave.eff. 2010")) %>%
  group_by(Model, gyear) %>%
  summarize(Mean = round(mean(Mode), 4), Min = round(min(`Lower bound`), 2), Max = round(max(`Upper bound`), 2)) %>%
  rename(Period = gyear)

kable(eff, format = "latex", 
      caption = paste0("Average technical efficiency ", "per period \\label{tab.tech}"), booktabs = T, linesep = "", align = c("l", "l", "c", "c", "c"), format.args = list(decimal.mark = '.', big.mark = ",")) %>%
  kable_styling(latex_options = "striped")

```


## References

